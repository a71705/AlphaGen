好的，这是一份详细的开发文档，采用卡片化任务的形式，旨在指导 AI 进行 WorldQuant Alpha 因子自动化挖掘系统的开发。我们将重点关注模块职责、API 接口细节、内存优化、鲁棒性以及精简性。

---

# WorldQuant Alpha 因子自动化挖掘系统 - 开发文档

**版本:** 1.0
**日期:** 2023年10月28日
**目标:** 构建一个高度自动化、智能、灵活、鲁棒且内存高效的 WorldQuant Brain Alpha 因子发现平台。

---

## 1. 核心指导原则

在整个开发过程中，AI 应严格遵循以下原则：

1.  **模块化与单一职责 (SRP):** 每个模块和函数应仅负责一件事，并做好这件事。
2.  **高可配置性:** 所有可变参数、策略选择、数据源路径等，均应通过外部 JSON/YAML 文件配置，而非硬编码。
3.  **鲁棒性与错误处理:** 针对 API 调用、文件操作、数据解析等所有可能出错的地方，实现健壮的错误捕获、日志记录、重试（如适用）和优雅降级。
4.  **内存优化:** 采取分批处理、惰性加载、即时释放、轻量化对象等策略，避免内存堆积，降低云服务器成本。
5.  **并发与效率:** 充分利用 Python 的多线程能力处理 I/O 密集型任务，并智能管理 API 调用速率，避免限流。
6.  **可恢复性:** 实现 GA 状态的持久化和自动恢复，支持断点续传。
7.  **可扩展性:** 接口设计应考虑未来功能扩展，尽量采用插件式或策略模式。
8.  **日志记录:** 使用 `logging` 模块进行统一、分级、按日期目录组织的日志输出。
9.  **测试驱动 (TDD) 思维:** 在编写代码之前，先考虑如何测试该功能。
10. **代码质量:** 遵循 PEP 8 规范，代码应清晰、注释得当、类型提示完整。

---

## 2. 项目结构概览

AI 应首先创建以下项目结构：

```
/project_root/
├── config/
│   ├── general_config.json      # 通用配置，包含WQB凭证路径、API URL、并发数等
│   ├── alpha_templates.json     # Alpha表达式模板定义
│   ├── operator_sets.json       # 可用操作符及其参数的取值范围
│   └── ga_config.json           # 遗传算法参数及适应度函数权重
├── data/
│   ├── ga_checkpoints/          # GA状态检查点
│   ├── successful_alphas/       # 合格Alpha的详细JSON
│   ├── alpha_pnl/               # 合格Alpha的PnL数据 (CSV)
│   ├── alpha_yearly_stats/      # 合格Alpha的年度统计数据 (CSV)
│   ├── available_datafields.json# 可用数据字段列表 (WQB爬取并更新)
│   └── inaccessible_ops_blacklist.json # 不可访问操作符/字段黑名单
├── logs/                        # 运行时日志 (按日期分文件夹)
│   └── YYYY-MM-DD/
│       ├── system.log
│       └── errors.log
├── src/
│   ├── config_manager.py        # ConfigManager 模块
│   ├── wqb_api_client.py        # WQB_API_Client 模块
│   ├── alpha_evolution_engine.py# AlphaEvolutionEngine 模块
│   ├── result_handler.py        # ResultHandler 模块
│   ├── system_orchestrator.py   # SystemOrchestrator 模块
│   └── utils.py                 # 通用工具函数 (如日志设置、AST转换辅助)
├── main.py                      # 系统启动入口
└── requirements.txt             # 项目依赖库
```

---

## 3. 卡片化开发任务

AI 应按照以下任务卡片的顺序进行开发。每个任务完成后，应进行单元测试以验证其功能。

### Task 01: 项目初始化与基础工具

*   **模块:** `project_root` (文件系统), `src/utils.py`
*   **功能:** 创建项目结构，设置基础依赖，实现日志初始化。
*   **描述:**
    *   创建上述所有文件夹和空文件。
    *   在 `requirements.txt` 中添加初始依赖：`requests`, `pandas`, `tqdm`, `pyparsing` (或 `ply`)。
    *   在 `src/utils.py` 中实现日志设置函数，支持按年/月/日创建日志文件夹和文件。
*   **依赖:** 无。
*   **验收标准:**
    *   项目结构正确创建。
    *   `pip install -r requirements.txt` 成功。
    *   调用日志设置函数后，`logs/YYYY-MM-DD/` 文件夹及日志文件成功生成。
*   **输入/输出:**
    *   `src/utils.py` 方法:
        ```python
        # src/utils.py
        import logging
        import os
        from datetime import datetime

        def setup_logging(base_log_dir="logs", log_level=logging.INFO):
            """
            配置系统日志，按日期创建文件夹。
            """
            log_date_dir = os.path.join(base_log_dir, datetime.now().strftime("%Y-%m-%d"))
            os.makedirs(log_date_dir, exist_ok=True)

            system_log_path = os.path.join(log_date_dir, "system.log")
            errors_log_path = os.path.join(log_date_dir, "errors.log")

            logger = logging.getLogger()
            logger.setLevel(log_level)

            # 避免重复添加handler (重要，防止多次调用setup_logging时重复输出)
            for handler in logger.handlers[:]: # 迭代副本，安全移除
                if isinstance(handler, (logging.FileHandler, logging.StreamHandler)):
                    logger.removeHandler(handler)

            # File Handler for all INFO and above
            file_handler = logging.FileHandler(system_log_path, encoding='utf-8')
            file_handler.setLevel(log_level)
            file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(module)s - %(funcName)s - %(message)s')
            file_handler.setFormatter(file_formatter)
            logger.addHandler(file_handler)

            # File Handler for ERROR only
            error_file_handler = logging.FileHandler(errors_log_path, encoding='utf-8')
            error_file_handler.setLevel(logging.ERROR)
            error_file_handler.setFormatter(file_formatter)
            logger.addHandler(error_file_handler)

            # Console Handler
            console_handler = logging.StreamHandler()
            console_handler.setLevel(log_level)
            console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            console_handler.setFormatter(console_formatter)
            logger.addHandler(console_handler)

            logging.info(f"日志已配置，输出到 {log_date_dir}")
            return logger # 返回配置好的logger实例
        ```
*   **内存/性能考虑:** 日志系统本身内存开销很小，主要涉及磁盘 I/O。

### Task 02: ConfigManager 模块开发

*   **模块:** `src/config_manager.py`
*   **功能:** 加载并管理所有系统配置。
*   **描述:** 实现一个类来加载所有 JSON 配置文件，提供方法访问配置数据，并支持动态更新特定配置（如数据字段列表、黑名单）。
*   **依赖:** T1.0 (文件系统)。
*   **验收标准:**
    *   能成功加载所有默认配置 JSON 文件。
    *   能通过方法正确访问到各项配置值。
    *   能动态更新 `available_datafields` 和 `inaccessible_ops_blacklist`。
*   **输入/输出:**
    *   `src/config_manager.py` 类: `ConfigManager`
        ```python
        # src/config_manager.py
        import json
        import os
        import logging

        class ConfigManager:
            _instance = None # 单例模式
            
            def __new__(cls, *args, **kwargs):
                if not cls._instance:
                    cls._instance = super().__new__(cls)
                return cls._instance

            def __init__(self, config_base_path="config/", data_base_path="data/"):
                if hasattr(self, '_initialized') and self._initialized:
                    return # 防止重复初始化
                self._initialized = True

                self.config_base_path = config_base_path
                self.data_base_path = data_base_path
                self.config = {}
                self._load_all_configs()

            def _load_json_file(self, file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
                except FileNotFoundError:
                    logging.warning(f"配置文件未找到: {file_path}. 将使用默认值或空数据。")
                    return {}
                except json.JSONDecodeError as e:
                    logging.error(f"配置文件解析错误: {file_path} - {e}. 请检查JSON格式。")
                    raise
                except Exception as e:
                    logging.error(f"加载配置文件时发生未知错误: {file_path} - {e}")
                    raise

            def _load_all_configs(self):
                # 加载主配置
                self.config['general'] = self._load_json_file(os.path.join(self.config_base_path, "general_config.json"))
                self.config['alpha_templates'] = self._load_json_file(os.path.join(self.config_base_path, "alpha_templates.json"))
                self.config['operator_sets'] = self._load_json_file(os.path.join(self.config_base_path, "operator_sets.json"))
                self.config['ga'] = self._load_json_file(os.path.join(self.config_base_path, "ga_config.json"))
                
                # 加载动态数据（默认空，后续由WQB_API_Client和ResultHandler更新）
                self.config['datafields'] = self._load_json_file(os.path.join(self.data_base_path, "available_datafields.json"))
                self.config['blacklist'] = self._load_json_file(os.path.join(self.data_base_path, "inaccessible_ops_blacklist.json"))

                logging.info("所有配置已加载。")

            def get(self, key_path: str):
                """
                通过点路径获取配置值。例如: "general.api_url"
                """
                keys = key_path.split('.')
                value = self.config
                try:
                    for key in keys:
                        value = value[key]
                    return value
                except KeyError:
                    logging.warning(f"配置键 '{key_path}' 未找到。")
                    return None # 或抛出更具体的异常

            def set_datafields(self, datafields: list):
                """
                更新可用数据字段列表并保存到文件。
                """
                self.config['datafields'] = datafields
                self._save_config_file(os.path.join(self.data_base_path, "available_datafields.json"), datafields)
                logging.info(f"可用数据字段列表已更新，共 {len(datafields)} 条。")

            def set_blacklist(self, blacklist: list):
                """
                更新不可访问操作符黑名单并保存到文件。
                """
                self.config['blacklist'] = blacklist
                self._save_config_file(os.path.join(self.data_base_path, "inaccessible_ops_blacklist.json"), blacklist)
                logging.info(f"不可访问操作符黑名单已更新，共 {len(blacklist)} 条。")

            def _save_config_file(self, file_path, data):
                """
                内部方法: 将数据保存到指定JSON文件。
                """
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=4, ensure_ascii=False)
                logging.debug(f"配置数据已保存到 {file_path}")

        ```
*   **内存/性能考虑:** 配置数据一次性加载到内存，但通常配置数据量不大，对内存影响可忽略。

### Task 03: WQB_API_Client 模块开发 - 基础功能

*   **模块:** `src/wqb_api_client.py`
*   **功能:** 认证、会话管理、基础 API 调用封装（带重试）。
*   **描述:** 实现 `WQB_API_Client` 类，负责与 WQB API 的认证、会话持久化和刷新、以及所有 API 请求的通用处理（包括重试机制）。
*   **依赖:** T2.0 (ConfigManager)。
*   **验收标准:**
    *   能成功登录 WQB 平台并保存/加载会话。
    *   会话过期能自动刷新或重登录。
    *   对任何 API 调用，能正确处理 `Retry-After` 头部进行重试。
    *   能处理 401 错误并触发重登录。
*   **输入/输出:**
    *   `src/wqb_api_client.py` 类: `WQB_API_Client`
        ```python
        # src/wqb_api_client.py
        import requests
        import os
        import json
        import pickle
        import time
        import logging
        from urllib.parse import urljoin
        from datetime import datetime, timedelta
        from concurrent.futures import Future, ThreadPoolExecutor # 提前导入，为T3.2做准备

        class WQB_API_Client:
            def __init__(self, config_manager):
                self.config_manager = config_manager
                self.session = self._initialize_session()
                self.base_url = self.config_manager.get("general.api_base_url")
                self.login_endpoint = urljoin(self.base_url, "authentication")
                self.alpha_endpoint = urljoin(self.base_url, "alphas")
                self.simulation_endpoint = urljoin(self.base_url, "simulations")
                self.data_fields_endpoint = urljoin(self.base_url, "data-fields")
                self.data_sets_endpoint = urljoin(self.base_url, "data-sets")

                self.credentials_file = self.config_manager.get("general.credentials_file")
                self.session_pkl_file = self.config_manager.get("general.session_pkl_file")
                self.blacklist_file = os.path.join(self.config_manager.data_base_path, "inaccessible_ops_blacklist.json")
                
                # 内部黑名单，通过ConfigManager同步
                self._inaccessible_ops_blacklist = self.config_manager.get("blacklist") or []

                # 用于批量提交的内部队列和锁
                self._batch_queue = []
                self._batch_queue_lock = threading.Lock()
                self._batch_submit_executor = ThreadPoolExecutor(max_workers=1) # 专门用于提交批次
                self._batch_monitor_executor = ThreadPoolExecutor(max_workers=self.config_manager.get("general.max_concurrent_simulations")) # 用于监控批次中的子Alpha

            def _initialize_session(self):
                s = requests.Session()
                s.headers.update({'Content-Type': 'application/json', 'Accept': 'application/json'})
                return s

            def _load_credentials(self):
                try:
                    with open(self.credentials_file, 'r', encoding='utf-8') as f:
                        creds = json.load(f)
                    return (creds["email"], creds["password"])
                except FileNotFoundError:
                    logging.error(f"凭证文件未找到: {self.credentials_file}. 请确保文件存在并包含 'email' 和 'password'。")
                    raise
                except json.JSONDecodeError:
                    logging.error(f"凭证文件格式错误: {self.credentials_file}. 请检查JSON格式。")
                    raise

            def _load_session(self):
                if os.path.exists(self.session_pkl_file):
                    try:
                        with open(self.session_pkl_file, 'rb') as f:
                            session = pickle.load(f)
                            # 检查pickle文件是否太旧 (例如，超过4小时，需要重新登录)
                            if time.time() - os.path.getmtime(self.session_pkl_file) > 4 * 3600:
                                logging.info("已保存的会话文件已过期，需要重新登录。")
                                return None
                            self.session = session # 重新赋值给当前实例
                            logging.info("已加载之前保存的会话。")
                            return session
                    except Exception as e:
                        logging.warning(f"加载会话文件失败: {e}. 将尝试重新登录。")
                        return None
                return None

            def _save_session(self):
                os.makedirs(os.path.dirname(self.session_pkl_file), exist_ok=True)
                with open(self.session_pkl_file, 'wb') as f:
                    pickle.dump(self.session, f)
                logging.info(f"会话已保存到 {self.session_pkl_file}")

            def login(self):
                """执行登录流程，包括生物识别认证"""
                logging.info("尝试登录 WorldQuant Brain...")
                self.session.auth = self._load_credentials()
                r = self.session.post(self.login_endpoint)

                if r.status_code == 401 and r.headers.get("WWW-Authenticate") == "persona":
                    persona_url = urljoin(r.url, r.headers["Location"])
                    logging.info(f"需要生物识别认证。请在浏览器中完成认证后按回车键继续: {persona_url}")
                    # 可以在这里使用webbrowser.open(persona_url) 自动打开浏览器
                    input() # 等待用户输入
                    r = self.session.post(persona_url) # 提交确认

                    while r.status_code != 201:
                        logging.warning("生物识别认证未完成。请重试并在完成后按回车键继续。")
                        input()
                        r = self.session.post(persona_url)

                if r.status_code != 201:
                    logging.error(f"登录失败: {r.status_code} - {r.text}")
                    # 清理凭证文件，强制下次重新输入 (仅在用户名/密码错误时)
                    if r.status_code == 401:
                        logging.warning("用户名或密码不正确。请删除credentials.json文件以重新输入。")
                    raise Exception("登录失败，请检查凭证。")

                self._save_session()
                logging.info("登录成功。")

            def refresh_session_if_needed(self):
                """
                检查会话是否过期，并尝试刷新或重新登录。
                """
                # 简单检查会话对象是否有效，以及过期时间
                if not self.session or not hasattr(self.session, 'auth') or not self.session.auth:
                    logging.info("会话不存在或未认证，尝试登录。")
                    self.login()
                    return

                # 检查会话是否已保存且未过期 (更严格的检查在_load_session中完成)
                if self._load_session(): # 尝试重新加载最新会话，如果成功则其内部已刷新
                    return

                # 尝试刷新，如果失败则重新登录
                try:
                    r = self.session.post(self.login_endpoint) # 尝试用现有session auth刷新token
                    if r.status_code == 201:
                        self._save_session()
                        logging.info("会话刷新成功。")
                        return
                    elif r.status_code == 401: # 会话过期或未授权
                        logging.info("会话已过期，尝试重新登录。")
                        self.login()
                    else:
                        logging.error(f"会话刷新失败，状态码: {r.status_code}, 响应: {r.text}. 尝试重新登录。")
                        self.login()
                except Exception as e:
                    logging.error(f"会话刷新过程中发生异常: {e}. 尝试重新登录。")
                    self.login()

            def _send_request_with_retry(self, method, url, json_data=None, params=None, max_retries=5):
                """
                内部方法: 发送带重试和Retry-After处理的API请求。
                """
                for attempt in range(max_retries + 1):
                    try:
                        response = self.session.request(method, url, json=json_data, params=params, timeout=30)
                        
                        if response.status_code == 429: # Too Many Requests
                            retry_after = int(response.headers.get("Retry-After", 5))
                            logging.warning(f"API 限流 (429)。{retry_after}秒后重试 (尝试 {attempt+1}/{max_retries})。")
                            time.sleep(retry_after)
                            continue # 继续下一次尝试

                        if response.status_code == 401: # Unauthorized
                            logging.warning("API 未授权 (401)。会话可能过期，尝试重新登录。")
                            self.login() # 重新登录
                            # 重新发送请求 (注意：这会重新计数尝试次数)
                            # 也可以选择在这里直接raise，让上层决定是否重试整个任务
                            time.sleep(1) # 等待登录完成
                            continue

                        response.raise_for_status() # 对 4xx/5xx 状态码抛出HTTPError
                        return response

                    except requests.exceptions.HTTPError as e:
                        logging.error(f"HTTP 错误: {e.response.status_code} - {e.response.text}. (尝试 {attempt+1}/{max_retries})")
                        # 403 Forbidden 可能是权限问题，不再重试
                        if e.response.status_code == 403:
                            logging.error(f"权限不足 (403): {url}. 不再重试此请求。")
                            self.add_to_blacklist("UNKNOWN_OP_OR_FIELD", f"403_Forbidden_at_{url_data_or_field}") # 动态黑名单处理
                            raise # 抛出异常，让上层决定如何处理
                        
                        if attempt < max_retries:
                            time.sleep(min(2 ** attempt, 30)) # 指数退避，最大30秒
                        else:
                            logging.error(f"API 请求最终失败: {method} {url}。")
                            raise # 最终失败，抛出异常

                    except requests.exceptions.ConnectionError as e:
                        logging.error(f"连接错误: {e}. (尝试 {attempt+1}/{max_retries})")
                        if attempt < max_retries:
                            time.sleep(min(2 ** attempt, 30))
                        else:
                            logging.error(f"API 连接最终失败: {method} {url}。")
                            raise

                    except requests.exceptions.Timeout as e:
                        logging.error(f"请求超时: {e}. (尝试 {attempt+1}/{max_retries})")
                        if attempt < max_retries:
                            time.sleep(min(2 ** attempt, 30))
                        else:
                            logging.error(f"API 请求最终超时: {method} {url}。")
                            raise

                    except Exception as e:
                        logging.error(f"发送请求时发生未知错误: {e}. (尝试 {attempt+1}/{max_retries})")
                        if attempt < max_retries:
                            time.sleep(min(2 ** attempt, 30))
                        else:
                            logging.error(f"API 请求最终失败: {method} {url}。")
                            raise

                raise Exception(f"请求失败，超出最大重试次数: {method} {url}") # Should not be reached if exceptions are raised above

            def add_to_blacklist(self, op_name: str, reason: str = "API_ERROR"):
                """
                将不可访问的操作符/字段添加到内存和持久化黑名单中。
                """
                if op_name not in [item['name'] for item in self._inaccessible_ops_blacklist]:
                    self._inaccessible_ops_blacklist.append({"name": op_name, "reason": reason, "timestamp": datetime.now().isoformat()})
                    self.config_manager.set_blacklist(self._inaccessible_ops_blacklist) # 持久化

            def clear_blacklist(self):
                """
                清除内存和持久化黑名单。
                """
                self._inaccessible_ops_blacklist = []
                self.config_manager.set_blacklist([]) # 持久化
                logging.info("不可访问操作符黑名单已清空。")

            # ----------------------------------------------------------------------
            # 下面的 API 调用方法会使用 _send_request_with_retry
            # ----------------------------------------------------------------------

            def get_available_datafields(self, instrument_type='EQUITY', region='USA', delay=1, universe='TOP3000'):
                """
                自动从 WQB 平台获取最新的数据字段列表。
                过滤掉当前账户权限无法访问的字段（如果API响应指示）。
                """
                logging.info("开始获取 WQB 数据字段列表...")
                datafields_list_flat = []
                limit = 50 # API默认或建议的每页限制

                # 初始请求，获取总数
                initial_url = f"{self.data_fields_endpoint}?" \
                              f"instrumentType={instrument_type}&region={region}&delay={delay}&universe={universe}&limit={limit}&offset=0"
                try:
                    initial_response = self._send_request_with_retry('GET', initial_url)
                    total_count = initial_response.json().get('count', 0)
                    if total_count == 0:
                        logging.warning("未获取到任何数据字段。")
                        return []
                    datafields_list_flat.extend(initial_response.json().get('results', []))
                except Exception as e:
                    logging.error(f"获取初始数据字段列表失败: {e}")
                    return []

                # 分页获取剩余数据
                for offset in range(limit, total_count, limit):
                    url = f"{self.data_fields_endpoint}?" \
                          f"instrumentType={instrument_type}&region={region}&delay={delay}&universe={universe}&limit={limit}&offset={offset}"
                    try:
                        response = self._send_request_with_retry('GET', url)
                        datafields_list_flat.extend(response.json().get('results', []))
                    except Exception as e:
                        logging.warning(f"获取数据字段分页 (offset={offset}) 失败: {e}. 可能未获取到全部字段。")
                        # 遇到错误，不再继续分页，返回已获取的部分
                        break
                
                # 提取字段ID，并根据权限过滤（如果API有明确权限字段）
                available_fields = []
                for item in datafields_list_flat:
                    field_id = item.get('id')
                    # WQB API通常不会在get_datafields直接返回权限不足的字段
                    # 但如果在后续模拟中发现权限问题，_send_request_with_retry会将其加入黑名单
                    if field_id:
                        available_fields.append(field_id)
                
                logging.info(f"成功获取 {len(available_fields)} 个数据字段。")
                return available_fields

            def get_alpha_details(self, alpha_id: str) -> dict:
                """获取 Alpha 的完整模拟结果 JSON"""
                url = f"{self.alpha_endpoint}/{alpha_id}"
                try:
                    response = self._send_request_with_retry('GET', url)
                    return response.json()
                except Exception as e:
                    logging.error(f"获取 Alpha {alpha_id} 详情失败: {e}")
                    return {}

            def get_alpha_pnl(self, alpha_id: str) -> pd.DataFrame:
                """获取 Alpha 模拟的 PnL 数据"""
                url = f"{self.alpha_endpoint}/{alpha_id}/recordsets/pnl"
                try:
                    response = self._send_request_with_retry('GET', url)
                    pnl_data = response.json().get("records", [])
                    if not pnl_data:
                        return pd.DataFrame()
                    pnl_df = pd.DataFrame(pnl_data, columns=["Date", "Pnl"])
                    pnl_df['Date'] = pd.to_datetime(pnl_df['Date'], format="%Y-%m-%d")
                    pnl_df['alpha_id'] = alpha_id
                    return pnl_df
                except Exception as e:
                    logging.error(f"获取 Alpha {alpha_id} PnL 失败: {e}")
                    return pd.DataFrame()

            def get_alpha_yearly_stats(self, alpha_id: str) -> pd.DataFrame:
                """获取 Alpha 模拟的年度统计数据"""
                url = f"{self.alpha_endpoint}/{alpha_id}/recordsets/yearly-stats"
                try:
                    response = self._send_request_with_retry('GET', url)
                    stats_data = response.json().get("records", [])
                    if not stats_data:
                        return pd.DataFrame()
                    columns = [dct["name"] for dct in response.json()["schema"]["properties"]]
                    yearly_stats_df = pd.DataFrame(stats_data, columns=columns)
                    yearly_stats_df['alpha_id'] = alpha_id
                    return yearly_stats_df
                except Exception as e:
                    logging.error(f"获取 Alpha {alpha_id} 年度统计失败: {e}")
                    return pd.DataFrame()

            def get_alpha_submission_checks(self, alpha_id: str) -> pd.DataFrame:
                """获取 Alpha 的提交检查结果"""
                url = f"{self.alpha_endpoint}/{alpha_id}/check"
                try:
                    response = self._send_request_with_retry('GET', url)
                    checks_data = response.json().get("is", {}).get("checks", [])
                    if not checks_data:
                        return pd.DataFrame()
                    checks_df = pd.DataFrame(checks_data)
                    checks_df['alpha_id'] = alpha_id
                    return checks_df
                except Exception as e:
                    logging.error(f"获取 Alpha {alpha_id} 提交检查失败: {e}")
                    return pd.DataFrame()

            def set_alpha_properties(self, alpha_id: str, name: str = None, color: str = None, tags: list = ["gen"]) -> None:
                """修改 Alpha 的描述参数（例如，设置标签）"""
                url = f"{self.alpha_endpoint}/{alpha_id}"
                params = {
                    "color": color,
                    "name": name,
                    "tags": tags,
                    "category": None,
                    "regular": {"description": None},
                    "combo": {"description": None},
                    "selection": {"description": None},
                }
                try:
                    self._send_request_with_retry('PATCH', url, json_data=params)
                    logging.debug(f"已为 Alpha {alpha_id} 设置属性。")
                except Exception as e:
                    logging.warning(f"设置 Alpha {alpha_id} 属性失败: {e}")

            # ----------------------------------------------------------------------
            # 批量模拟提交的异步接口
            # ----------------------------------------------------------------------
            def submit_alpha_for_simulation(self, payload: dict) -> Future:
                """
                提交单个 Alpha 模拟任务。内部根据配置决定是加入批处理队列还是直接提交。
                返回一个 Future 对象，其结果将是该 Alpha 的原始 WQB 结果 JSON。
                """
                future = Future()
                with self._batch_queue_lock:
                    self._batch_queue.append((payload, future))
                    # 立即提交批次 (这里可以根据策略调整，例如，达到N个或者等待X秒后提交)
                    if len(self._batch_queue) >= self.config_manager.get("general.batch_size"):
                        self._submit_current_batch_async()
                return future
            
            def _submit_current_batch_async(self):
                """
                内部方法: 异步提交当前批次队列中的任务。
                此方法应在 _batch_queue_lock 内部被调用。
                """
                if not self._batch_queue:
                    return

                # 获取当前批次队列的副本并清空原队列
                current_batch_data = list(self._batch_queue)
                self._batch_queue.clear()
                
                # 提交到专门的执行器，避免阻塞主循环
                self._batch_submit_executor.submit(self._process_batch_submission, current_batch_data)

            def _process_batch_submission(self, batch_data: list):
                """
                实际执行批处理提交和监控的内部方法。
                此方法在独立的线程中运行。
                """
                payloads = [item[0] for item in batch_data]
                futures_to_resolve = [item[1] for item in batch_data]

                try:
                    if self.config_manager.get("general.enable_batch_simulation"):
                        # 尝试使用批量 API
                        logging.info(f"提交批量模拟请求 ({len(payloads)} 个Alpha)...")
                        response = self._send_request_with_retry('POST', urljoin(self.simulation_endpoint, "batch"), json_data=payloads)
                        
                        # 检查WQB是否实际返回了子模拟URL
                        batch_progress_urls = response.json().get('locations', [])
                        if not batch_progress_urls:
                             logging.warning(f"批量模拟请求成功，但未返回子模拟URL。可能批量模拟失败或没有子任务。响应: {response.text}")
                             for fut in futures_to_resolve: # 解析所有等待中的Future为失败
                                 if not fut.done(): fut.set_exception(Exception("批量提交未返回有效子任务"))
                             return
                        
                        # 为每个子任务启动监控，并将其结果传递回对应的Future
                        for i, progress_url in enumerate(batch_progress_urls):
                            # 如果批次大小与实际返回的URL数量不匹配，需要更健壮的索引
                            if i < len(futures_to_resolve):
                                self._batch_monitor_executor.submit(self._monitor_and_resolve_future, progress_url, futures_to_resolve[i])
                            else:
                                logging.warning(f"批量返回URL数量 ({len(batch_progress_urls)}) 与提交数量 ({len(payloads)}) 不匹配。")

                    else:
                        # 不使用批量 API，逐个提交 (控制并发在EvolutionEngine)
                        # 注意：这里的并发控制将由EvolutionEngine通过MAX_CONCURRENT来实现，
                        # WQB_API_Client只负责单次提交的重试和错误处理。
                        logging.info(f"逐个提交模拟请求 ({len(payloads)} 个Alpha)...")
                        for i, payload in enumerate(payloads):
                            response = self._send_request_with_retry('POST', self.simulation_endpoint, json_data=payload)
                            progress_url = response.headers.get('Location')
                            if progress_url:
                                self._batch_monitor_executor.submit(self._monitor_and_resolve_future, progress_url, futures_to_resolve[i])
                            else:
                                logging.error(f"提交单个Alpha模拟失败，未获取到进度URL。Payload: {payload}")
                                if not futures_to_resolve[i].done(): futures_to_resolve[i].set_exception(Exception("提交失败，无进度URL"))

                except requests.exceptions.HTTPError as e:
                    if e.response.status_code == 403 and self.config_manager.get("general.enable_batch_simulation"):
                        logging.error("批量模拟权限不足 (403 Forbidden)。将禁用批量模拟功能。")
                        self.config_manager.set("general.enable_batch_simulation", False) # 动态关闭
                    for fut in futures_to_resolve: # 解析所有等待中的Future为失败
                        if not fut.done(): fut.set_exception(e)
                except Exception as e:
                    logging.error(f"处理批处理提交时发生错误: {e}")
                    for fut in futures_to_resolve:
                        if not fut.done(): fut.set_exception(e)

            def _monitor_and_resolve_future(self, progress_url: str, future_to_resolve: Future):
                """
                内部方法: 监控单个模拟进度，并将其结果设置到对应的Future。
                """
                try:
                    final_wqb_result = self.monitor_simulation_progress(progress_url)
                    if final_wqb_result:
                        future_to_resolve.set_result(final_wqb_result)
                    else:
                        future_to_resolve.set_exception(Exception(f"Alpha模拟失败或超时: {progress_url}"))
                except Exception as e:
                    logging.error(f"监控Alpha进度或设置Future结果失败: {e}")
                    if not future_to_resolve.done(): future_to_resolve.set_exception(e)


            def monitor_simulation_progress(self, progress_url: str) -> dict:
                """
                监控单个模拟任务的进度，直到完成并获取 Alpha 的完整结果 JSON。
                """
                max_poll_time = self.config_manager.get("general.simulation_poll_timeout_seconds") # 例如300秒
                poll_interval = 5 # 初始轮询间隔，WQB通常会给Retry-After
                start_time = time.time()
                
                while time.time() - start_time < max_poll_time:
                    try:
                        response = self._send_request_with_retry('GET', progress_url)
                        status = response.json().get("status")
                        alpha_id_from_progress = response.json().get("alpha")

                        if status == "COMPLETE" and alpha_id_from_progress:
                            # 模拟完成，获取最终的alpha详细信息
                            return self.get_alpha_details(alpha_id_from_progress)
                        elif status in ["FAILED", "ERROR"]:
                            error_message = response.json().get("message", "未知错误")
                            logging.error(f"Alpha 模拟失败: {progress_url} - {error_message}")
                            # 尝试从错误信息中提取操作符加入黑名单
                            self._extract_and_add_to_blacklist(error_message)
                            return {} # 返回空字典表示失败
                        elif response.headers.get('Retry-After', '0') != '0':
                            # API要求等待
                            time.sleep(int(response.headers['Retry-After']))
                        else:
                            # 状态不是COMPLETE, FAILED, ERROR，也没有Retry-After，继续等待
                            time.sleep(poll_interval) # 使用默认轮询间隔
                            
                    except Exception as e:
                        logging.error(f"监控 Alpha 进度时发生异常: {e}")
                        # 尝试从异常中提取操作符加入黑名单
                        self._extract_and_add_to_blacklist(str(e))
                        return {} # 返回空字典表示失败

                logging.warning(f"Alpha 模拟超时: {progress_url}")
                return {} # 超时返回空字典

            def _extract_and_add_to_blacklist(self, error_message: str):
                """
                内部方法: 从错误消息中提取不可访问的操作符或字段并加入黑名单。
                """
                # 示例正则表达式，需要根据WQB实际错误消息调整
                match_op = re.search(r'operator "([^"]+)" is not supported', error_message)
                if match_op:
                    op_name = match_op.group(1)
                    self.add_to_blacklist(op_name, "UNSUPPORTED_OPERATOR_API_ERROR")
                    logging.info(f"动态黑名单: 添加操作符 '{op_name}' (API错误)。")
                    return
                
                match_field_perm = re.search(r'access to field "([^"]+)" is denied', error_message)
                if match_field_perm:
                    field_name = match_field_perm.group(1)
                    self.add_to_blacklist(field_name, "FIELD_PERMISSION_DENIED")
                    logging.info(f"动态黑名单: 添加数据字段 '{field_name}' (权限不足)。")
                    return
                
                # 更多匹配模式可以添加...

        ```
*   **内存/性能考虑:**
    *   `_send_request_with_retry` 采用短连接，避免内存泄露。
    *   `ThreadPoolExecutor` 管理并发，`MAX_CONCURRENT` 需根据云服务器内存和 WQB API 限制调优。
    *   `get_available_datafields` 分页获取，避免一次性加载所有字段到内存。
    *   `_batch_queue` 临时持有 `payload` 和 `Future`，批次处理后会清空，避免长时间内存堆积。
    *   `_batch_submit_executor` 和 `_batch_monitor_executor` 使用了单独的线程池，确保提交和监控不会阻塞主循环，且线程数可控。

### Task 04: AlphaEvolutionEngine 模块开发 - 基础结构与生成

*   **模块:** `src/alpha_evolution_engine.py`, `src/utils.py` (AST转换)
*   **功能:** 实现 Alpha 表达式的生成（模板填充、树结构）、适应度计算和 GA 核心流程的框架。
*   **描述:** 定义 `Individual` 类，实现基于 AST 的 Alpha 表达式生成器，并搭建 GA 主循环框架。
*   **依赖:** T2.0 (ConfigManager), T3.0 (WQB_API_Client)。
*   **验收标准:**
    *   能生成基于模板的 Alpha 表达式。
    *   能将字符串表达式解析为 AST，再将 AST 转换为字符串。
    *   能计算出 Alpha 的复合连续适应度分数。
*   **输入/输出:**
    *   `src/alpha_evolution_engine.py` 类: `Individual`, `AlphaEvolutionEngine`
        ```python
        # src/alpha_evolution_engine.py
        import logging
        import random
        from collections import OrderedDict
        from concurrent.futures import Future, ThreadPoolExecutor
        import math
        import pandas as pd
        import re # 用于占位符替换和解析

        # 引入pyparsing用于AST转换，假设在utils.py中实现
        # from .utils import parse_expression_to_ast, generate_expression_from_ast # T4.1中实现

        class Individual:
            """表示遗传算法中的一个Alpha个体"""
            def __init__(self, expression_ast, simulation_params: dict, fitness_score=0.0, alpha_id=None):
                self.expression_ast = expression_ast # Alpha表达式的AST表示
                self.simulation_params = simulation_params # 模拟参数，如decay, universe等
                self.fitness_score = fitness_score
                self.alpha_id = alpha_id # WQB平台上的Alpha ID

            # 精简：不再存储完整的payload，需要时再生成
            # 精简：不再存储完整的wqb_raw_result，只存储必要信息和通过ResultHandler持久化

        class AlphaEvolutionEngine:
            def __init__(self, config_manager, wqb_api_client, result_handler):
                self.config_manager = config_manager
                self.wqb_api_client = wqb_api_client
                self.result_handler = result_handler

                # GA 参数
                self.population_size = self.config_manager.get("ga.initial_population_size")
                self.max_generations = self.config_manager.get("ga.max_generations")
                self.injection_rate = self.config_manager.get("ga.injection_rate")
                self.min_population_size = self.config_manager.get("ga.min_population_size")
                self.max_population_size = self.config_manager.get("ga.max_population_size")

                # 可用操作符和字段（从ConfigManager获取最新）
                self.terminal_values = self.config_manager.get("operator_sets.terminal_values")
                self.ts_ops = self.config_manager.get("operator_sets.ts_ops")
                self.binary_ops = self.config_manager.get("operator_sets.binary_ops")
                self.ts_ops_values = self.config_manager.get("operator_sets.ts_ops_values")
                self.unary_ops = self.config_manager.get("operator_sets.unary_ops")
                self.inaccessible_ops_blacklist = self.config_manager.get("blacklist") # 引用实时黑名单

                # 模拟参数选择范围
                self.decay_choices = self.config_manager.get("operator_sets.decay_choices")
                self.delay_choices = self.config_manager.get("operator_sets.delay_choices")
                self.truncation_choices = self.config_manager.get("operator_sets.truncation_choices")
                self.universe_choices = self.config_manager.get("operator_sets.universe_choices")
                self.neutralization_choices = self.config_manager.get("operator_sets.neutralization_choices")
                self.ga_genes = self.config_manager.get("ga.genes") # 哪些参数参与GA

                self.current_population = []
                self.current_generation = 0
                self.total_successful_alphas = 0

            # --- Alpha 表达式生成方法 ---
            def _generate_random_simulation_params(self) -> dict:
                """生成一组随机的模拟参数"""
                return {
                    'decay': random.choice(self.decay_choices),
                    'delay': random.choice(self.delay_choices),
                    'truncation': random.choice(self.truncation_choices),
                    'universe': random.choice(self.universe_choices),
                    'neutralization': random.choice(self.neutralization_choices)
                }

            def _get_random_datafield(self) -> str:
                """从可用数据字段中随机选择一个，并过滤黑名单"""
                available_fields = self.config_manager.get("datafields")
                if not available_fields:
                    logging.warning("没有可用的数据字段，请先爬取。")
                    return "close" # 默认一个通用字段以防万一
                
                # 过滤黑名单字段
                filtered_fields = [f for f in available_fields if f not in [item['name'] for item in self.inaccessible_ops_blacklist]]
                if not filtered_fields:
                    logging.warning("所有数据字段都在黑名单中，将使用通用字段。")
                    return "close"
                
                return random.choice(filtered_fields)

            def _get_random_operator(self, op_type: str) -> str:
                """从指定类型的操作符中随机选择一个，并过滤黑名单"""
                ops_list = self.config_manager.get(f"operator_sets.{op_type}_ops")
                if not ops_list:
                    logging.warning(f"没有可用的 '{op_type}' 操作符。")
                    return ""
                
                filtered_ops = [op for op in ops_list if op not in [item['name'] for item in self.inaccessible_ops_blacklist]]
                if not filtered_ops:
                    logging.warning(f"所有 '{op_type}' 操作符都在黑名单中。")
                    return random.choice(ops_list) # 回退到非过滤列表，可能会再次失败，但避免死循环
                
                return random.choice(filtered_ops)

            def generate_alpha_from_template(self) -> Individual:
                """
                根据模板填充模式生成一个Alpha个体 (AST)。
                """
                templates = self.config_manager.get("alpha_templates")
                if not templates:
                    raise ValueError("没有可用的Alpha模板，请检查'alpha_templates.json'。")
                
                template_item = random.choice(templates)
                template_str = template_item['template']
                data_space = template_item['data_space']
                shared_space = template_item['shared_space']

                # 填充数据空间占位符
                for placeholder, values in data_space.items():
                    # 优先使用外部定义的可用数据字段，如果模板中特定定义了，则使用模板的
                    final_values = [v for v in values if v not in [item['name'] for item in self.inaccessible_ops_blacklist]] or values # 过滤黑名单
                    if not final_values: final_values = [self._get_random_datafield()] # 兜底
                    
                    selected_value = random.choice(final_values)
                    template_str = re.sub(re.escape(placeholder), selected_value, template_str)

                # 填充共享空间占位符
                for placeholder, values in shared_space.items():
                    final_values = [v for v in values if v not in [item['name'] for item in self.inaccessible_ops_blacklist]] or values # 过滤黑名单
                    if not final_values: # 兜底
                        if "op>" in placeholder: # 是操作符
                            if "binary" in placeholder: final_values = self.binary_ops
                            elif "ts" in placeholder: final_values = self.ts_ops
                            elif "unary" in placeholder: final_values = self.unary_ops
                            elif "group" in placeholder: final_values = self.config_manager.get("operator_sets.group_ops")
                        elif "days>" in placeholder: # 是天数参数
                            final_values = self.ts_ops_values # 默认天数参数
                        else: final_values = ["1"] # 兜底通用值
                    
                    selected_value = random.choice(final_values)
                    template_str = re.sub(re.escape(placeholder), str(selected_value), template_str) # 确保是字符串

                # 检查是否还有未替换的占位符
                missing_keys = re.findall(r"<[^>]+>", template_str)
                if missing_keys:
                    logging.warning(f"模板中以下变量未被替换: {missing_keys}. 表达式可能无效。")
                    raise ValueError(f"未替换占位符: {missing_keys}")
                
                # 转换为AST
                # expression_ast = parse_expression_to_ast(template_str.strip()) # T4.1实现
                # 暂时用一个简单的字符串表示AST
                expression_ast = f"AST({template_str.strip()})" # 临时占位符

                return Individual(expression_ast, self._generate_random_simulation_params())

            def generate_alpha_structurally(self) -> Individual:
                """
                根据树结构进化模式生成一个Alpha个体 (AST)。
                这部分需要AST操作的复杂逻辑，目前只做占位符。
                """
                # 简化的结构生成示例 (实际应调用更复杂的树构建和操作逻辑)
                op = random.choice(self.binary_ops)
                field1 = self._get_random_datafield()
                field2 = self._get_random_datafield()
                
                # 确保生成的表达式不包含黑名单中的操作符或字段
                if op in [item['name'] for item in self.inaccessible_ops_blacklist] or \
                   field1 in [item['name'] for item in self.inaccessible_ops_blacklist] or \
                   field2 in [item['name'] for item in self.inaccessible_ops_blacklist]:
                   logging.debug("结构生成中遇到黑名单元素，将重试生成。")
                   # 递归调用自身或抛出异常，直到生成一个合法的
                   return self.generate_alpha_structurally() # 简单递归，实际应有循环计数器防止无限递归

                # 假设这是AST的某种表示
                expression_ast = f"AST({op}({field1},{field2}))" 
                
                return Individual(expression_ast, self._generate_random_simulation_params())


            def generate_random_individual(self) -> Individual:
                """
                根据配置的生成策略，生成一个新的随机个体。
                """
                generation_mode = self.config_manager.get("ga.alpha_generation_mode")
                if generation_mode == "template_based":
                    return self.generate_alpha_from_template()
                elif generation_mode == "structural_based":
                    return self.generate_alpha_structurally()
                else:
                    logging.warning(f"未知Alpha生成模式: {generation_mode}. 默认使用模板模式。")
                    return self.generate_alpha_from_template()

            # --- 适应度函数 ---
            def calculate_fitness(self, metrics: dict) -> float:
                """
                根据可配置的复合连续适应度函数计算Alpha的评分。
                metrics包含sharpe, fitness, returns, drawdown, turnover等。
                """
                fitness_config = self.config_manager.get("ga.fitness_function")
                
                sharpe = metrics.get('sharpe', 0.0)
                wq_fitness = metrics.get('fitness', 0.0) # WQ平台自带的fitness
                returns = metrics.get('returns', 0.0)
                drawdown = metrics.get('drawdown', 0.0)
                turnover = metrics.get('turnover', 0.0)

                # 处理潜在的0或NaN值，避免除以零或无穷大
                if math.isclose(drawdown, 0.0): drawdown = 1e-6 # 避免除以0
                if math.isclose(turnover, 0.0): turnover = 1e-6 # 避免除以0
                
                # 确保drawdown是正数，如果API返回负数表示回撤，则取绝对值
                drawdown = abs(drawdown)

                # 应用配置的权重和公式
                # 示例公式: (w_s*S + w_f*F + w_r*R) / (w_d*D + w_t*T^2 + epsilon)
                weighted_numerator = (
                    fitness_config.get('weight_sharpe', 1.0) * sharpe +
                    fitness_config.get('weight_wq_fitness', 1.0) * wq_fitness +
                    fitness_config.get('weight_returns', 1.0) * returns
                )
                weighted_denominator = (
                    fitness_config.get('weight_drawdown', 1.0) * drawdown +
                    fitness_config.get('weight_turnover', 1.0) * (turnover ** fitness_config.get('turnover_power', 2)) +
                    fitness_config.get('epsilon', 1e-6) # 小常数避免除以零
                )
                
                # 确保分母非零
                if math.isclose(weighted_denominator, 0.0):
                    weighted_denominator = 1e-12 # 极小值

                calculated_fitness = weighted_numerator / weighted_denominator
                
                # 也可以增加惩罚项，例如惩罚过高或过低的换手率
                if turnover > fitness_config.get('max_turnover_threshold', 0.7) or \
                   turnover < fitness_config.get('min_turnover_threshold', 0.01):
                    calculated_fitness *= fitness_config.get('turnover_penalty_factor', 0.5) # 惩罚

                # 增加对WQB平台特定检查的惩罚 (从ResultHandler传递过来)
                # 例如，如果WQ的is_valid返回false，可以给一个很低的适应度
                if not metrics.get('wq_is_valid', True):
                    calculated_fitness *= fitness_config.get('invalid_penalty_factor', 0.1)

                return calculated_fitness

            # --- GA 主循环框架 (run_optimization) ---
            def run_optimization(self, resume: bool = False):
                """
                启动遗传算法优化主循环。
                """
                if resume:
                    # T5.1实现：从ResultHandler加载GA状态
                    self.current_population, self.current_generation, self.total_successful_alphas = \
                        self.result_handler.load_ga_state()
                    logging.info(f"从检查点恢复，当前代: {self.current_generation}, 已发现合格Alpha: {self.total_successful_alphas}")
                else:
                    logging.info("开始新的遗传算法优化。")
                    self.current_population = self._initialize_population()
                    self.current_generation = 0
                    self.total_successful_alphas = 0

                # 主循环
                for gen in range(self.current_generation, self.max_generations):
                    self.current_generation = gen
                    logging.info(f"--- 遗传算法 第 {gen+1} 代开始 ---")

                    # 1. 模拟评估当前种群
                    evaluated_population = self._evaluate_population_with_replenishing_concurrency()
                    
                    # 2. 从评估结果中筛选合格Alpha并保存
                    successful_this_gen = 0
                    for individual, is_qualified in evaluated_population:
                        if is_qualified:
                            self.total_successful_alphas += 1
                            successful_this_gen += 1
                            logging.info(f"发现合格Alpha: {individual.alpha_id} (Fitness: {individual.fitness_score:.4f})")
                            # ResultHandler已在内部保存
                    
                    logging.info(f"第 {gen+1} 代成功发现 {successful_this_gen} 个合格Alpha。总计 {self.total_successful_alphas} 个。")

                    # 3. 检查终止条件
                    if self.total_successful_alphas >= self.config_manager.get("ga.target_successful_alphas", 50):
                        logging.info(f"已达到目标合格Alpha数量 {self.total_successful_alphas}。停止优化。")
                        break
                    
                    # 4. 保存GA状态 (T5.1实现)
                    self.result_handler.save_ga_state(self.current_population, self.current_generation, self.total_successful_alphas)

                    # 5. 生成下一代 (选择、交叉、变异、注入)
                    self.current_population = self._generate_next_generation(evaluated_population)
                    
                    # 6. 自适应种群大小调整
                    self._adjust_population_size(successful_this_gen)
                    
                logging.info("遗传算法优化结束。")

            def _initialize_population(self) -> list[Individual]:
                """创建初始种群"""
                population = []
                for _ in range(self.population_size):
                    try:
                        individual = self.generate_random_individual()
                        population.append(individual)
                    except Exception as e:
                        logging.error(f"初始化个体时发生错误: {e}. 跳过。")
                        continue
                return population

            def _evaluate_population_with_replenishing_concurrency(self) -> list[tuple[Individual, bool]]:
                """
                使用替补式并发评估种群中的每个Alpha。
                返回一个列表，每个元素为 (individual, is_qualified)。
                """
                evaluated_results = []
                tasks_to_submit = list(self.current_population) # 待提交的任务队列
                
                # 创建一个线程池用于并发模拟
                # WQB_API_Client内部已经有线程池，这里主要用于管理Future的生命周期
                max_concurrent = self.config_manager.get("general.max_concurrent_simulations")
                with ThreadPoolExecutor(max_workers=max_concurrent) as executor:
                    running_futures: dict[Future, Individual] = {} # 存储Future及其对应的Individual

                    # 初始提交任务
                    for _ in range(max_concurrent):
                        if tasks_to_submit:
                            individual = tasks_to_submit.pop(0)
                            # individual.expression_ast 转换为字符串用于payload
                            expr_str = individual.expression_ast # 临时占位，T4.1会转换为字符串
                            payload = self._build_simulation_payload(expr_str, individual.simulation_params)
                            
                            # 提交到WQB_API_Client，它返回Future
                            future = self.wqb_api_client.submit_alpha_for_simulation(payload)
                            running_futures[future] = individual
                            logging.debug(f"已提交Alpha: {expr_str[:50]}...")
                        else:
                            break # 没有更多任务可提交

                    # 替补式并发主循环
                    with tqdm(total=len(self.current_population), desc=f"Gen {self.current_generation+1} Simulating") as pbar:
                        while running_futures:
                            # 等待任意一个任务完成
                            done_futures = set()
                            for future in concurrent.futures.as_completed(running_futures.keys()):
                                done_futures.add(future)
                                break # 只处理一个完成的任务，然后立即补充新任务
                            
                            for future in done_futures:
                                individual = running_futures.pop(future)
                                try:
                                    # 获取WQB API Client返回的原始WQB结果JSON
                                    raw_wqb_result = future.result() 
                                    
                                    # 传递给ResultHandler处理，它会进行详细处理、适应度计算和持久化
                                    qualified, fitness_score, processed_data = \
                                        self.result_handler.handle_simulation_result(
                                            alpha_id=raw_wqb_result.get('id'), # 获取模拟结果中的ID
                                            original_payload=self._build_simulation_payload(individual.expression_ast, individual.simulation_params), # 再次构建payload
                                            wqb_raw_result=raw_wqb_result
                                        )
                                    individual.fitness_score = fitness_score
                                    individual.alpha_id = raw_wqb_result.get('id') # 更新个体ID
                                    evaluated_results.append((individual, qualified))
                                    logging.debug(f"Alpha {individual.alpha_id} 评估完成，适应度: {fitness_score:.4f}")

                                except Exception as e:
                                    logging.error(f"Alpha模拟或处理失败 ({individual.expression_ast[:50]}...): {e}")
                                    # 如果模拟失败，给一个极低的适应度，确保GA能将其淘汰
                                    individual.fitness_score = -1e9 # 负无穷大
                                    evaluated_results.append((individual, False)) # 不合格

                                pbar.update(1) # 更新进度条

                                # 补充新任务
                                if tasks_to_submit:
                                    next_individual = tasks_to_submit.pop(0)
                                    next_expr_str = next_individual.expression_ast # 临时占位，T4.1会转换为字符串
                                    next_payload = self._build_simulation_payload(next_expr_str, next_individual.simulation_params)
                                    next_future = self.wqb_api_client.submit_alpha_for_simulation(next_payload)
                                    running_futures[next_future] = next_individual
                            
                return evaluated_results

            def _build_simulation_payload(self, alpha_expression_str: str, simulation_params: dict) -> dict:
                """
                根据Alpha表达式字符串和模拟参数构建WQB API的payload。
                """
                settings = {
                    'instrumentType': 'EQUITY',
                    'region': self.config_manager.get("general.default_region"),
                    'universe': simulation_params['universe'],
                    'language': 'FASTEXPR',
                    'decay': simulation_params['decay'],
                    'delay': simulation_params['delay'],
                    'truncation': simulation_params['truncation'],
                    'neutralization': simulation_params['neutralization'],
                    'pasteurization': self.config_manager.get("general.default_pasteurization"),
                    'testPeriod': self.config_manager.get("general.default_test_period"),
                    'unitHandling': self.config_manager.get("general.default_unit_handling"),
                    'nanHandling': self.config_manager.get("general.default_nan_handling"),
                    'visualization': False,
                }
                return {
                    'type': 'REGULAR',
                    'settings': settings,
                    'regular': alpha_expression_str
                }

            # --- 生成下一代 (选择、交叉、变异) ---
            def _generate_next_generation(self, evaluated_population: list[tuple[Individual, bool]]) -> list[Individual]:
                """
                根据评估结果生成下一代种群。
                """
                # 1. 精英选择: 选出表现最佳的合格个体作为精英
                qualified_individuals = [ind for ind, qualified in evaluated_population if qualified]
                qualified_individuals.sort(key=lambda ind: ind.fitness_score, reverse=True)
                
                num_elites = self.config_manager.get("ga.elite_count")
                elites = qualified_individuals[:num_elites]
                logging.info(f"选出 {len(elites)} 个精英个体。")

                next_generation = list(elites) # 下一代从精英开始

                while len(next_generation) < self.population_size:
                    # 2. 注入随机新个体
                    if random.random() < self.injection_rate:
                        try:
                            new_individual = self.generate_random_individual()
                            next_generation.append(new_individual)
                            continue
                        except Exception as e:
                            logging.warning(f"注入新个体失败: {e}. 跳过。")
                            continue

                    # 3. 选择父代 (如果精英数量不足，则从所有个体中选)
                    parents_pool = elites if elites else [ind for ind, _ in evaluated_population]
                    if len(parents_pool) < 2: # 确保有足够父代进行交叉
                        next_generation.append(self.generate_random_individual())
                        continue # 无法交叉，直接注入随机个体

                    parent1 = random.choice(parents_pool)
                    parent2 = random.choice(parents_pool)

                    # 4. 交叉 (T6.4实现)
                    child = self._crossover(parent1, parent2) if random.random() < self.config_manager.get("ga.crossover_rate") else parent1 # 交叉失败或不交叉则保留父代

                    # 5. 变异 (T6.4实现)
                    if random.random() < self.config_manager.get("ga.mutation_rate"):
                        child = self._mutate(child)
                    
                    next_generation.append(child)
                
                # 确保种群大小与当前设定一致 (可能因为四舍五入或随机注入导致略有偏差)
                next_generation = next_generation[:self.population_size]
                logging.info(f"下一代种群大小: {len(next_generation)}")
                return next_generation

            def _adjust_population_size(self, successful_this_gen: int):
                """
                根据当前代成功率自适应调整种群大小。
                """
                success_rate = successful_this_gen / self.population_size if self.population_size > 0 else 0
                
                if success_rate <= self.config_manager.get("ga.population_adjust_thresholds.low_success_rate", 0.05):
                    self.population_size = min(self.population_size * 2, self.max_population_size)
                    logging.info(f"成功率低 ({success_rate:.2f})，扩大种群到 {self.population_size}")
                elif success_rate >= self.config_manager.get("ga.population_adjust_thresholds.high_success_rate", 0.3):
                    self.population_size = max(int(self.population_size * 0.7), self.min_population_size)
                    logging.info(f"成功率高 ({success_rate:.2f})，收缩种群到 {self.population_size}")
                
                # 动态调整交叉和变异率 (可以根据成功率或其他指标)
                # 假设配置中定义了这些规则
                c_rate_config = self.config_manager.get("ga.adaptive_crossover_rate_rules")
                m_rate_config = self.config_manager.get("ga.adaptive_mutation_rate_rules")

                # 这是一个简化的例子，实际规则可能更复杂，需要遍历规则列表
                if success_rate <= c_rate_config.get("threshold_low", 0.05):
                    self.config_manager.set_runtime_ga_param("crossover_rate", c_rate_config.get("value_low", 0.9))
                elif success_rate <= c_rate_config.get("threshold_mid", 0.15):
                    self.config_manager.set_runtime_ga_param("crossover_rate", c_rate_config.get("value_mid", 0.7))
                else:
                    self.config_manager.set_runtime_ga_param("crossover_rate", c_rate_config.get("value_high", 0.5))

                if success_rate <= m_rate_config.get("threshold_low", 0.05):
                    self.config_manager.set_runtime_ga_param("mutation_rate", m_rate_config.get("value_low", 0.8))
                elif success_rate <= m_rate_config.get("threshold_mid", 0.15):
                    self.config_manager.set_runtime_ga_param("mutation_rate", m_rate_config.get("value_mid", 0.5))
                else:
                    self.config_manager.set_runtime_ga_param("mutation_rate", m_rate_config.get("value_high", 0.3))

                logging.info(f"自适应调整: 交叉率={self.config_manager.get('ga.crossover_rate'):.2f}, 变异率={self.config_manager.get('ga.mutation_rate'):.2f}")

            # --- 遗传操作 (交叉和变异) ---
            def _crossover(self, parent1: Individual, parent2: Individual) -> Individual:
                """
                对两个父代个体进行交叉操作，生成子代。
                """
                child_params = {}
                for gene in self.ga_genes:
                    child_params[gene] = random.choice([parent1.simulation_params[gene], parent2.simulation_params[gene]])

                # 结构交叉 (如果启用且是结构化生成模式)
                child_ast = parent1.expression_ast # 默认子代继承父代1的结构
                if self.config_manager.get("ga.alpha_generation_mode") == "structural_based":
                    # 假设这里调用的是一个在utils.py中实现的AST交叉函数
                    # child_ast = perform_ast_crossover(parent1.expression_ast, parent2.expression_ast)
                    # 临时占位符
                    logging.debug("执行结构交叉占位符。")

                return Individual(child_ast, child_params)

            def _mutate(self, individual: Individual) -> Individual:
                """
                对个体进行变异操作。
                """
                mutated_params = dict(individual.simulation_params) # 复制一份，避免修改原对象
                
                # 参数变异
                key_to_mutate = random.choice(self.ga_genes)
                if key_to_mutate == 'decay':
                    mutated_params[key_to_mutate] = random.choice(self.decay_choices)
                elif key_to_mutate == 'delay':
                    mutated_params[key_to_mutate] = random.choice(self.delay_choices)
                elif key_to_mutate == 'truncation':
                    mutated_params[key_to_mutate] = random.choice(self.truncation_choices)
                elif key_to_mutate == 'universe':
                    mutated_params[key_to_mutate] = random.choice(self.universe_choices)
                elif key_to_mutate == 'neutralization':
                    mutated_params[key_to_mutate] = random.choice(self.neutralization_choices)
                # ... 其他参数
                
                # 结构变异 (如果启用且是结构化生成模式)
                mutated_ast = individual.expression_ast # 默认不变
                if self.config_manager.get("ga.alpha_generation_mode") == "structural_based":
                    # 假设这里调用的是一个在utils.py中实现的AST变异函数
                    # mutated_ast = perform_ast_mutation(individual.expression_ast)
                    # 临时占位符
                    logging.debug("执行结构变异占位符。")

                return Individual(mutated_ast, mutated_params, individual.fitness_score, individual.alpha_id)
        ```
*   **内存/性能考虑:**
    *   `Individual` 对象应保持轻量。`expression_ast` 理论上是一个引用，不包含原始字符串。
    *   `_evaluate_population_with_replenishing_concurrency` 采用 `ThreadPoolExecutor` 和 `as_completed` 实现替补式并发，最大化吞吐量。
    *   `_build_simulation_payload` 在每次提交时创建，用完即释放。
    *   `_generate_next_generation` 在生成新个体时，会复制父代参数，避免不必要的副作用。

### Task 05: AST 转换工具 (utils.py)

*   **模块:** `src/utils.py`
*   **功能:** 实现 Alpha 表达式字符串与 AST 之间的双向转换。
*   **描述:** 使用 `pyparsing` 或 `ply` 库来实现 Alpha 表达式的 BNF 文法解析和 AST 构建。
*   **依赖:** 无 (但被 `AlphaEvolutionEngine` 使用)。
*   **验收标准:**
    *   能将简单的 Alpha 表达式（如 `add(close, open)`）解析为 AST 结构。
    *   能将 AST 结构正确转换回字符串表达式。
    *   能处理包含括号、数字、多种操作符和字段的复杂表达式。
*   **输入/输出:**
    *   `src/utils.py` 方法: `parse_expression_to_ast`, `generate_expression_from_ast`, `Node` (AST节点类)
        ```python
        # src/utils.py (在setup_logging下方追加)
        from pyparsing import Word, alphas, alphanums, Suppress, Group, delimitedList, nums, Optional, Keyword, Forward, ZeroOrMore
        # 可以定义一个简单的Node类来表示AST节点
        class Node:
            def __init__(self, value, children=None):
                self.value = value
                self.children = children if children is not None else []

            def __repr__(self):
                if self.children:
                    return f"Node({self.value}, {self.children})"
                return f"Node({self.value})"

        # --------------------------------------------------------------------------
        # 简化版Alpha表达式文法 (需要根据实际WQB FASTEXPR语法细化和完善)
        # --------------------------------------------------------------------------
        def setup_alpha_parser():
            identifier = Word(alphas, alphanums + '_').setName("identifier")
            number = Word(nums + '.').setName("number")

            # Forward declare expression for recursion
            expr = Forward()

            # Function call format: func(arg1, arg2, ...)
            func_name = identifier
            lparen, rparen = Suppress("("), Suppress(")")
            comma = Suppress(",")
            
            # Arguments can be identifiers, numbers, or nested expressions
            arg = (identifier | number | expr)

            # Define a function call structure for parsing
            func_call = Group(func_name + lparen + delimitedList(arg) + rparen).setName("function_call")

            # Expression can be a simple identifier, number, or a function call
            expr << (func_call | identifier | number)

            # Define how to build the AST from parsed elements
            def convert_to_ast(t):
                if isinstance(t, str):
                    return Node(t) # Simple identifier or number
                elif len(t) > 1 and isinstance(t[0], str): # Function call
                    func_name = t[0]
                    children = [convert_to_ast(arg) for arg in t[1:]]
                    return Node(func_name, children)
                else: # Grouped expression
                    return Node(t[0].value, t[0].children) # Pass through the already created Node

            expr.setParseAction(convert_to_ast)
            return expr

        alpha_parser = setup_alpha_parser()

        def parse_expression_to_ast(expression_str: str) -> Node:
            """
            将Alpha表达式字符串解析为AST。
            """
            try:
                # pyparsing.parseString返回一个Result对象，[0]通常是根元素
                # 或者直接返回已经执行了setParseAction的Node实例
                return alpha_parser.parseString(expression_str, parseAll=True)[0]
            except Exception as e:
                logging.error(f"解析表达式失败: '{expression_str}' - {e}")
                raise

        def generate_expression_from_ast(node: Node) -> str:
            """
            将AST结构转换为Alpha表达式字符串。
            """
            if not isinstance(node, Node):
                return str(node) # 如果不是Node，直接返回字符串表示

            if not node.children: # 叶子节点 (identifier or number)
                return str(node.value)
            
            # 非叶子节点 (function call)
            args_str = ", ".join(generate_expression_from_ast(child) for child in node.children)
            return f"{node.value}({args_str})"
        ```
*   **内存/性能考虑:** `pyparsing` 或 `ply` 在解析复杂表达式时会有一定内存开销，但通常单个表达式的 AST 不会太大。应确保 AST 对象在用完后及时释放引用。

### Task 06: ResultHandler 模块开发

*   **模块:** `src/result_handler.py`
*   **功能:** 处理模拟结果、筛选、适应度计算、所有数据持久化、GA 状态管理。
*   **描述:** 核心的数据处理和存储模块。
*   **依赖:** T2.0 (ConfigManager), T3.0 (WQB_API_Client), T4.0 (AlphaEvolutionEngine)。
*   **验收标准:**
    *   能正确解析 WQB 原始结果并提取所有详细信息。
    *   能根据配置的筛选标准判断 Alpha 是否合格。
    *   能将合格 Alpha 的详细信息（JSON、CSV）持久化到磁盘，不堆积内存。
    *   能正确保存和加载 GA 状态。
*   **输入/输出:**
    *   `src/result_handler.py` 类: `ResultHandler`
        ```python
        # src/result_handler.py
        import logging
        import json
        import os
        import pandas as pd
        from datetime import datetime

        class ResultHandler:
            def __init__(self, config_manager, wqb_api_client, alpha_evolution_engine):
                self.config_manager = config_manager
                self.wqb_api_client = wqb_api_client
                self.alpha_evolution_engine = alpha_evolution_engine # 用于调用 fitness_function
                
                self.successful_alphas_dir = os.path.join(self.config_manager.data_base_path, "successful_alphas")
                self.alpha_pnl_dir = os.path.join(self.config_manager.data_base_path, "alpha_pnl")
                self.alpha_yearly_stats_dir = os.path.join(self.config_manager.data_base_path, "alpha_yearly_stats")
                self.ga_checkpoints_dir = os.path.join(self.config_manager.data_base_path, "ga_checkpoints")

                os.makedirs(self.successful_alphas_dir, exist_ok=True)
                os.makedirs(self.alpha_pnl_dir, exist_ok=True)
                os.makedirs(self.alpha_yearly_stats_dir, exist_ok=True)
                os.makedirs(self.ga_checkpoints_dir, exist_ok=True)

            def handle_simulation_result(self, alpha_id: str, original_payload: dict, wqb_raw_result: dict) -> tuple[bool, float, dict]:
                """
                处理单个Alpha模拟结果，进行数据提取、丰富、筛选、适应度计算并持久化。
                返回 (是否合格, 适应度分数, 处理后的详细数据)。
                """
                if not alpha_id or not wqb_raw_result:
                    logging.warning(f"接收到空或无效的WQB原始结果，Alpha ID: {alpha_id}")
                    return False, -1e9, {} # 失败个体给极低适应度

                processed_data = {
                    "alpha_id": alpha_id,
                    "expression_str": original_payload.get('regular'),
                    "simulation_settings": original_payload.get('settings'),
                    "wqb_raw_result": wqb_raw_result # 原始API结果，方便调试
                }

                # 提取IS统计数据
                is_stats = wqb_raw_result.get('is', {})
                processed_data['sharpe'] = is_stats.get('sharpe')
                processed_data['fitness'] = is_stats.get('fitness')
                processed_data['returns'] = is_stats.get('returns')
                processed_data['drawdown'] = is_stats.get('drawdown')
                processed_data['turnover'] = is_stats.get('turnover')
                processed_data['wq_is_valid'] = all(c['result']!='FAIL' for c in is_stats.get('checks', [])) # WQ平台内部有效性检查
                
                # 获取并保存额外数据（如果配置需要）
                # 内存优化：这些方法返回DataFrame，如果不需要长时间持有，立即写入文件
                if self.config_manager.get("general.get_pnl", False):
                    pnl_df = self.wqb_api_client.get_alpha_pnl(alpha_id)
                    if not pnl_df.empty:
                        self._save_df_to_csv(pnl_df, self.alpha_pnl_dir, f"{alpha_id}_pnl.csv")
                        processed_data['pnl_file'] = f"{alpha_id}_pnl.csv"
                
                if self.config_manager.get("general.get_yearly_stats", False):
                    yearly_stats_df = self.wqb_api_client.get_alpha_yearly_stats(alpha_id)
                    if not yearly_stats_df.empty:
                        self._save_df_to_csv(yearly_stats_df, self.alpha_yearly_stats_dir, f"{alpha_id}_yearly_stats.csv", index=False)
                        processed_data['yearly_stats_file'] = f"{alpha_id}_yearly_stats.csv"

                if self.config_manager.get("general.get_submission_checks", False):
                    submission_checks_df = self.wqb_api_client.get_alpha_submission_checks(alpha_id)
                    if not submission_checks_df.empty:
                        # 对于提交检查，如果需要存储所有细节，也可以考虑保存为JSON或CSV
                        # processed_data['submission_checks'] = submission_checks_df.to_dict(orient='records')
                        pass # 默认不存储，因为通常只关心是否合格

                # 1. 适应度计算
                fitness_score = self.alpha_evolution_engine.calculate_fitness(processed_data)
                
                # 2. 合格性筛选 (基于适应度分数和配置的额外阈值)
                is_qualified = fitness_score >= self.config_manager.get("ga.fitness_function.min_acceptable_fitness", 1.0) and \
                               processed_data['wq_is_valid'] # WQ平台内部验证也必须通过
                               
                # 3. 持久化合格Alpha
                if is_qualified:
                    self._save_qualified_alpha_details(processed_data)
                    logging.info(f"合格Alpha已保存: {alpha_id} (Fitness: {fitness_score:.4f})")
                
                return is_qualified, fitness_score, processed_data

            def _save_df_to_csv(self, df: pd.DataFrame, directory: str, filename: str, **kwargs):
                """内部方法: 将DataFrame保存到CSV文件"""
                file_path = os.path.join(directory, filename)
                try:
                    df.to_csv(file_path, encoding='utf-8', **kwargs)
                    logging.debug(f"DataFrame已保存到 {file_path}")
                except Exception as e:
                    logging.error(f"保存DataFrame到 {file_path} 失败: {e}")

            def _save_qualified_alpha_details(self, alpha_data: dict):
                """内部方法: 将合格Alpha的详细信息保存为JSON文件"""
                alpha_id = alpha_data['alpha_id']
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                file_path = os.path.join(self.successful_alphas_dir, f"{alpha_id}_{timestamp}.json")
                
                # 内存优化：直接写入磁盘，不保留在内存中
                try:
                    with open(file_path, 'w', encoding='utf-8') as f:
                        json.dump(alpha_data, f, indent=4, ensure_ascii=False)
                    logging.debug(f"合格Alpha详细信息已保存到 {file_path}")
                except Exception as e:
                    logging.error(f"保存合格Alpha {alpha_id} 详细信息失败: {e}")

            # --- GA 状态持久化 ---
            def save_ga_state(self, population: list, generation: int, total_successful: int):
                """
                保存遗传算法的当前状态（种群、代数、已发现合格Alpha数量）。
                """
                checkpoint_file = os.path.join(self.ga_checkpoints_dir, f"ga_checkpoint_{generation:04d}.json")
                
                # 内存优化：种群中的Individual对象可能含有AST，不直接序列化AST
                # Individual对象只存储表达式字符串和模拟参数
                serializable_population = []
                for individual in population:
                    # 将AST转换为字符串，确保可序列化
                    expr_str = individual.expression_ast # 临时占位，T4.1会转换为字符串
                    serializable_population.append({
                        "expression_str": expr_str,
                        "simulation_params": individual.simulation_params,
                        "fitness_score": individual.fitness_score,
                        "alpha_id": individual.alpha_id
                    })

                state = {
                    "generation": generation,
                    "total_successful_alphas": total_successful,
                    "population": serializable_population,
                    "timestamp": datetime.now().isoformat()
                }
                
                try:
                    # 使用原子性写入 (写入临时文件再重命名)
                    temp_file = checkpoint_file + ".tmp"
                    with open(temp_file, 'w', encoding='utf-8') as f:
                        json.dump(state, f, indent=4, ensure_ascii=False)
                    os.replace(temp_file, checkpoint_file) # 原子性替换
                    logging.info(f"GA 状态已保存到 {checkpoint_file}")
                except Exception as e:
                    logging.error(f"保存GA状态失败: {e}")

            def load_ga_state(self) -> tuple[list, int, int]:
                """
                加载最新的遗传算法状态。
                返回 (population, generation, total_successful_alphas)。
                """
                latest_checkpoint = None
                latest_gen = -1
                
                # 查找最新检查点
                for f_name in os.listdir(self.ga_checkpoints_dir):
                    if f_name.startswith("ga_checkpoint_") and f_name.endswith(".json"):
                        try:
                            gen_num = int(f_name.split("_")[2].split(".")[0])
                            if gen_num > latest_gen:
                                latest_gen = gen_num
                                latest_checkpoint = os.path.join(self.ga_checkpoints_dir, f_name)
                        except ValueError:
                            continue # 忽略格式不符的文件
                
                if latest_checkpoint:
                    try:
                        with open(latest_checkpoint, 'r', encoding='utf-8') as f:
                            state = json.load(f)
                        
                        loaded_population = []
                        for individual_data in state.get("population", []):
                            expr_str = individual_data.get("expression_str")
                            if expr_str:
                                # 将字符串表达式转换回AST (这里需要T4.1的方法)
                                # expression_ast = parse_expression_to_ast(expr_str) # 临时占位
                                expression_ast = f"AST({expr_str})" # 临时占位
                                loaded_population.append(self.alpha_evolution_engine.Individual(
                                    expression_ast=expression_ast,
                                    simulation_params=individual_data.get("simulation_params", {}),
                                    fitness_score=individual_data.get("fitness_score", 0.0),
                                    alpha_id=individual_data.get("alpha_id")
                                ))

                        logging.info(f"GA 状态已从 {latest_checkpoint} 加载。")
                        return loaded_population, state.get("generation", 0), state.get("total_successful_alphas", 0)

                    except Exception as e:
                        logging.error(f"加载GA状态文件 {latest_checkpoint} 失败: {e}. 将从头开始。")
                        return [], 0, 0
                
                logging.info("未找到GA检查点，将从头开始。")
                return [], 0, 0

            # --- 查看已发现Alpha ---
            def load_successful_alphas(self) -> list[dict]:
                """
                加载所有已保存的合格Alpha的详细信息。
                """
                all_alphas = []
                for f_name in os.listdir(self.successful_alphas_dir):
                    if f_name.endswith(".json"):
                        file_path = os.path.join(self.successful_alphas_dir, f_name)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                alpha_data = json.load(f)
                                all_alphas.append(alpha_data)
                        except Exception as e:
                            logging.warning(f"加载合格Alpha文件 {f_name} 失败: {e}")
                logging.info(f"已加载 {len(all_alphas)} 个合格Alpha。")
                return all_alphas

            def format_for_display(self, alpha_list: list[dict]) -> pd.DataFrame:
                """
                将合格Alpha列表转换为Pandas DataFrame，以便在控制台显示。
                """
                if not alpha_list:
                    return pd.DataFrame()
                
                # 提取关键信息，确保DataFrame不会过于庞大
                display_data = []
                for alpha in alpha_list:
                    display_data.append({
                        "ID": alpha.get("alpha_id"),
                        "Expression_Preview": alpha.get("expression_str", "")[:100] + "...",
                        "Sharpe": alpha.get("sharpe"),
                        "Fitness": alpha.get("fitness"),
                        "Turnover": alpha.get("turnover"),
                        "Region": alpha.get("simulation_settings", {}).get("region"),
                        "Universe": alpha.get("simulation_settings", {}).get("universe"),
                        "Saved_File": f"{alpha.get('alpha_id')}_{datetime.fromisoformat(alpha.get('wqb_raw_result',{}).get('dateCreated', datetime.now().isoformat())[:-1]).strftime('%Y%m%d_%H%M%S')}.json" # 假设文件名格式
                    })
                
                df = pd.DataFrame(display_data)
                # 排序 (例如按Fitness降序)
                if 'Fitness' in df.columns:
                    df = df.sort_values(by='Fitness', ascending=False)
                return df
        ```
*   **内存/性能考虑:**
    *   **核心优化点：** 所有持久化操作（`_save_df_to_csv`, `_save_qualified_alpha_details`, `save_ga_state`）都设计为**直接写入磁盘**，避免在内存中累积大量数据。
    *   `load_ga_state` 和 `load_successful_alphas` 只有在需要时才加载数据，并且 `load_successful_alphas` 可以只加载元数据，避免一次性加载所有原始 JSON。
    *   `format_for_display` 只提取关键信息生成 DataFrame，避免将所有原始数据加载到显示 DataFrame 中。

### Task 07: SystemOrchestrator 模块开发

*   **模块:** `src/system_orchestrator.py`
*   **功能:** 系统入口，协调各组件工作，提供控制台菜单交互。
*   **描述:** 实现 `SystemOrchestrator` 类，作为整个系统的启动器和用户交互界面。
*   **依赖:** T1.0 (utils), T2.0 (ConfigManager), T3.0 (WQB_API_Client), T4.0 (AlphaEvolutionEngine), T5.0 (ResultHandler)。
*   **验收标准:**
    *   系统能成功启动，显示主菜单。
    *   菜单选项能正确触发相应功能。
    *   能处理用户中断 (Ctrl+C) 并安全退出。
*   **输入/输出:**
    *   `src/system_orchestrator.py` 类: `SystemOrchestrator`
        ```python
        # src/system_orchestrator.py
        import logging
        import sys
        import traceback # 用于打印完整的异常信息

        # 导入所有组件
        from .config_manager import ConfigManager
        from .wqb_api_client import WQB_API_Client
        from .alpha_evolution_engine import AlphaEvolutionEngine
        from .result_handler import ResultHandler
        from .utils import setup_logging # 日志设置函数

        class SystemOrchestrator:
            def __init__(self):
                self._initialize_components()
                logging.info("系统初始化完成。")

            def _initialize_components(self):
                # 1. 初始化日志 (确保在所有其他初始化之前)
                # 这里只调用一次，避免重复配置。日志级别从config中获取
                logger = setup_logging(log_level=logging.INFO) # 初始默认INFO，后续可从config加载

                # 2. 初始化配置管理器
                self.config_manager = ConfigManager()
                # 从ConfigManager获取实际的日志级别并重新设置
                log_level_str = self.config_manager.get("general.log_level", "INFO").upper()
                logger.setLevel(getattr(logging, log_level_str, logging.INFO))
                
                # 3. 初始化WQB API客户端
                self.wqb_api_client = WQB_API_Client(self.config_manager)

                # 4. 初始化ResultHandler (需要wqb_api_client的引用，但alpha_evolution_engine的引用在初始化alpha_evolution_engine后再传递)
                self.result_handler = ResultHandler(self.config_manager, self.wqb_api_client, None) # 暂时传递None

                # 5. 初始化AlphaEvolutionEngine (需要ResultHandler和wqb_api_client的引用)
                self.alpha_evolution_engine = AlphaEvolutionEngine(self.config_manager, self.wqb_api_client, self.result_handler)
                
                # 回填ResultHandler中的alpha_evolution_engine引用
                self.result_handler.alpha_evolution_engine = self.alpha_evolution_engine

            def start(self):
                """系统启动入口，显示主菜单并处理用户交互"""
                try:
                    # 尝试登录WQB
                    self.wqb_api_client.refresh_session_if_needed()
                    
                    self._main_menu_loop()
                except Exception as e:
                    logging.critical(f"系统启动失败: {e}\n{traceback.format_exc()}")
                    sys.exit(1) # 强制退出

            def _main_menu_loop(self):
                """主菜单循环"""
                while True:
                    print("\n" + "="*30)
                    print("  WorldQuant Alpha 挖掘系统")
                    print("="*30)
                    print("1. 启动 Alpha 挖掘 (遗传优化)")
                    print("2. 爬取/更新数据字段列表")
                    print("3. 查看已发现的合格 Alpha")
                    print("4. 系统设置")
                    print("5. 黑名单管理")
                    print("6. 退出")
                    print("="*30)
                    
                    choice = input("请选择操作: ").strip()

                    try:
                        if choice == '1':
                            self._run_alpha_mining()
                        elif choice == '2':
                            self._update_datafields()
                        elif choice == '3':
                            self._view_successful_alphas()
                        elif choice == '4':
                            self._system_settings()
                        elif choice == '5':
                            self._manage_blacklist()
                        elif choice == '6':
                            logging.info("安全退出系统。")
                            break
                        else:
                            print("无效选择，请重新输入。")
                    except Exception as e:
                        logging.error(f"操作失败: {e}\n{traceback.format_exc()}")
                        print(f"操作过程中发生错误: {e}. 请查看日志获取详情。")

            def _run_alpha_mining(self):
                """启动Alpha因子挖掘流程"""
                resume_choice = input("是否从上次进度恢复？(y/n，默认为y): ").lower()
                resume = (resume_choice == 'y' or resume_choice == '')
                
                try:
                    self.alpha_evolution_engine.run_optimization(resume=resume)
                except KeyboardInterrupt:
                    logging.info("用户中断挖掘过程。正在保存当前状态...")
                    # GA引擎内部会处理保存状态
                except Exception as e:
                    logging.critical(f"Alpha挖掘过程中发生致命错误: {e}\n{traceback.format_exc()}")
                    print("挖掘异常终止，请查看日志获取详细信息。")

            def _update_datafields(self):
                """爬取并更新数据字段列表"""
                print("正在爬取/更新数据字段列表...")
                try:
                    data_fields = self.wqb_api_client.get_available_datafields()
                    # get_available_datafields内部已调用config_manager.set_datafields进行保存
                    print(f"数据字段列表更新完成，共 {len(data_fields)} 条可用字段。")
                except Exception as e:
                    logging.error(f"爬取数据字段失败: {e}\n{traceback.format_exc()}")
                    print("爬取数据字段失败，请查看日志。")

            def _view_successful_alphas(self):
                """查看已发现的合格Alpha"""
                print("正在加载已发现的合格 Alpha...")
                try:
                    all_alphas = self.result_handler.load_successful_alphas()
                    if all_alphas:
                        df = self.result_handler.format_for_display(all_alphas)
                        print("\n=== 合格 Alpha 概览 ===")
                        print(df.to_string()) # to_string() 防止截断
                        # 也可以考虑导出到临时文件，然后用webbrowser打开HTML
                    else:
                        print("暂未发现合格 Alpha。")
                except Exception as e:
                    logging.error(f"查看合格 Alpha 失败: {e}\n{traceback.format_exc()}")
                    print("加载合格 Alpha 失败，请查看日志。")

            def _system_settings(self):
                """系统设置菜单 (待实现具体功能)"""
                print("\n=== 系统设置 ===")
                print("1. 查看当前配置")
                print("2. (占位符) 修改并发数")
                print("3. (占位符) 修改日志级别")
                print("4. 返回主菜单")
                
                sub_choice = input("请选择操作: ").strip()
                if sub_choice == '1':
                    print("\n当前核心配置概览:")
                    print(f"并发模拟任务数: {self.config_manager.get('general.max_concurrent_simulations')}")
                    print(f"是否启用批量模拟: {self.config_manager.get('general.enable_batch_simulation')}")
                    print(f"日志级别: {self.config_manager.get('general.log_level')}")
                    # 更多配置信息可以按需打印
                elif sub_choice == '4':
                    pass
                else:
                    print("功能待实现或无效选择。")

            def _manage_blacklist(self):
                """黑名单管理菜单"""
                while True:
                    print("\n=== 黑名单管理 ===")
                    print("1. 查看当前黑名单")
                    print("2. 手动清除黑名单")
                    print("3. 返回主菜单")
                    
                    sub_choice = input("请选择操作: ").strip()
                    if sub_choice == '1':
                        blacklist = self.config_manager.get("blacklist")
                        if blacklist:
                            print("\n当前黑名单内容:")
                            for item in blacklist:
                                print(f"- {item.get('name')} (原因: {item.get('reason')}, 时间: {item.get('timestamp')})")
                        else:
                            print("黑名单为空。")
                    elif sub_choice == '2':
                        confirm = input("确定要清除所有黑名单项目吗？这可能会导致系统重新尝试访问之前失败的字段/操作符。(y/n): ").lower()
                        if confirm == 'y':
                            try:
                                self.wqb_api_client.clear_blacklist()
                                print("黑名单已成功清除。")
                            except Exception as e:
                                logging.error(f"清除黑名单失败: {e}\n{traceback.format_exc()}")
                                print("清除黑名单失败，请查看日志。")
                        else:
                            print("已取消清除操作。")
                    elif sub_choice == '3':
                        break
                    else:
                        print("无效选择，请重新输入。")

        ```
*   **内存/性能考虑:** `SystemOrchestrator` 本身不持有大量数据，主要负责协调。内存消耗极低。

### Task 08: `main.py` 启动文件

*   **模块:** `main.py`
*   **功能:** 系统的入口点。
*   **描述:** 实例化 `SystemOrchestrator` 并启动系统。
*   **依赖:** 所有其他模块。
*   **验收标准:** 运行 `python main.py` 能启动系统。
*   **输入/输出:**
    *   `main.py`
        ```python
        # main.py
        import logging
        from src.system_orchestrator import SystemOrchestrator
        from src.utils import setup_logging

        if __name__ == "__main__":
            # 初始设置日志 (级别可以从config.json中获取，但为了引导这里先默认设置)
            # 配置管理器初始化时会读取日志级别，并重新设置logger级别
            setup_logging() 
            
            logging.info("系统启动中...")
            orchestrator = SystemOrchestrator()
            orchestrator.start()
        ```

---

**AI 开发指导总结：**

*   **模块化开发：** 严格按照任务卡片中定义的模块进行代码编写，每个模块一个文件。
*   **API 接口严格遵循：** 各模块之间的交互，务必使用文档中定义的函数签名、参数和返回值。
*   **异常处理：** 在所有与外部系统（文件系统、API）交互的地方，务必使用 `try-except` 块进行异常捕获和日志记录。
*   **内存优化：** 牢记内存优化原则，特别是在处理列表、DataFrame 和循环时，避免不必要的内存拷贝和长期持有大对象。
*   **逐步实现：** 建议从 **Task 01** 开始，逐个任务实现，并在每个任务完成后进行测试，以确保代码的正确性。
*   **占位符替换：** 临时占位符（如 `f"AST({template_str.strip()})"`）在后续任务中会替换为真实的 AST 转换逻辑。

祝 AI 开发顺利！